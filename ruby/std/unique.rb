require 'std/raise'
require 'std/module_logging'
require 'std/UniqueIDConfig'
require 'std/view/Viewable'
require 'std/InheritableClassVariables'

# Include this module to indicate that instances of a class should be totally unique.
# Call the 'use_id' class method to set the attribute that defines the unique id for the class.
# If you wish to use an autogenerated integer id, then call 'auto_id'.
# TBD: document 'use_id_context' 
module Unique
  include EnumerableSubclasses
  include IncludableClassMethods
  include InheritableClassVariables
  include Raise
  include ModuleLogging
  include UniqueIDConfig
  
  self.log = false
  
  attr_inherit :unique_id_symbol
  attr_inherit :unique_id_context
    
  module ClassMethods
    def object_for_unique_id(id, uniqueid_context, absence_fatal = true)
      if uniqueid_context.nil?
        if !unique_has_global_context?
          raise "Nil context is only valid for global context."
        end
        
        uniqueid_context = UniqueID.global_registry
      end

      found_object = uniqueid_context[id]
      
      if found_object.nil? && absence_fatal
        Unique.raise "No object registered for ID: #{id}"
      end
      
      found_object
    end
    
    def registry_value_for(object)
      object
    end
    
    def use_id(symbol)
      @unique_id_symbol = symbol
      # The id symbol is not marked persistent because to_yaml defines it explicitly.
      # It requires special handling during loading.
    end
    
    def auto_id(symbol=:unique_auto_id)
      raise "Method with name '#{symbol}' already defined." if instance_methods().include?(symbol)
      @unique_id_symbol = symbol

      define_method(symbol) do
        return @unique_id unless @unique_id.nil?

        if @unique_id_auto.nil?
          @@unique_id_auto ||= 0
          @unique_id_auto = @@unique_id_auto
          @@unique_id_auto += 1
        end

        @unique_id_auto
      end
    end

    def use_id_context(host_symbol, host_registry_symbol)
      @unique_id_context = [host_symbol, host_registry_symbol]
    end
    
    def use_global_id_context
      @unique_id_global_context = true
    end
    
    def unique_context_host_for(object)
      if unique_has_global_context?
        nil
      elsif !unique_id_context()
        UniqueID.raise("Class '#{self}' does not have a context host. Ensure the class uses one of the attributes 'use_id_context' or 'use_global_id_context'.")
      else
        object.send(unique_id_context()[0])
      end
    end
    
    def unique_context_from_host(host_object)
      if !host_object.kind_of?(UniqueHost)
        UniqueID.raise("Host object for '#{self}' is not a UniqueHost ('#{host_object}', class #{host_object.class}).")
      end
        
      registry = host_object.send(unique_id_context()[1])
      registry = registry._hash
      
      if !registry
        UniqueID.raise("Unique id context host method '#{@unique_id_context[0]}.#{@unique_id_context[1]}' returned nil.")
      end
      
      registry
    end
    
    def unique_context_for(object)
      if unique_has_global_context?
        UniqueID.global_registry()
      else
        if !unique_id_context()
          UniqueID.raise("Object with class '#{object.class}' has no unique id context defined. You must use one of the class attributes 'use_id_context' or 'use_global_id_context'.")
        end
        
        host = object.send(unique_id_context()[0])
          
        if host == nil
          UniqueID.raise("Unique id context method '#{unique_id_context()[0]}' returned nil.")
        end
        
        unique_context_from_host(host)
      end
    end
    
    def unique_has_global_context?
      @unique_id_global_context == true
    end
      
    def valid_id?(id)
      id.nil? == false
    end
  end
  
  def clone
    Unique.raise "#{self.class} instances must be unique and should not be cloned."
  end
  
  def dup
    Unique.raise "#{self.class} instances must be unique and should not be dup-ed."
  end
  
  def ensure_id
    unique_id()
  end
  
  def to_yaml(opts={})
    YAML::quick_emit( nil, opts ) do |out|
      out.map( taguri, to_yaml_style() ) do |map|
        map.add( 'class', self.class.name )
        if unique_id() != self #temp only 
          map.add( 'unique_id', unique_id() )
          map.add( 'unique_context_host', unique_context_host() ) if !self.class.unique_has_global_context?
        end
      end
    end
  end
  
  def to_yaml_type
    "!david,2009/unique"
  end
  
  def bind
    bind_id(unique_id())
  end
  
  def bind_id(id)
    super

    Unique.log {
      context = if self.class.unique_has_global_context?
        '(global)'
      else
        unique_context_host()
      end
       
      "Object with class '#{self.class}' bound to id '#{id}' under context host '#{context}'." 
    }
  end
  
  def ensure_bind
    bind if @unique_id.nil?
  end
  
  def unique_id
    id = evaluate_id()
    
    if !@unique_id.nil? && !@unique_id.eql?(UniqueID::UNBOUND_UNIQUE_ID) && @unique_id != id
      Unique.raise "#{self.class}: the id has changed since it was bound. The id must remain constant during the object's lifetime. (previous id '#{@unique_id}' != new id '#{id}')"
    end
    
    id
  end

  def unique_context_host
    self.class.unique_context_host_for(self)
  end
  
  # Bad name, there's also a class inherited variable/method called unique_id_context(). Fix this.
  def uniqueid_context
    self.class.unique_context_for(self)
  end

  def uniqueidconfig_can_bind_on_load?(was_cloned)
    !was_cloned && self.class.unique_has_global_context?
  end
  
  class Unresolved < UniqueIDConfig::Unresolved
    # tbd: remove context_host, it can be inferred
    def initialize(id, object_class, context_host = nil)
      super(id, object_class)
      @object_class = object_class
      
      if context_host.nil? && !@object_class.unique_has_global_context?
        raise "Objects of type #{@object_class} don't have a global context, so an Unresolved reference to a context host must be specified."
      end

      @context_host = context_host
    end

    def config_process_unresolved(attributeReference, host)
      if @context_host
        @context_host.config_process_unresolved(AttributeReference::Instance.new(:context_host), self)
        @context_host.resolve
        @context = @object_class.unique_context_from_host(@context_host)
        raise "Nil context retrieved from context host." if !@context 
      end
      
      super
    end
    
    def resolveIfPossible(id_remapping_hash)
      Unique.log { "Trying to resolve reference to unique with id '#{@id}'" }
      
      if !@context_host.nil? && !@context_host.config_resolved?
        Unique.log { "  Failed, context host with id #{@context_host.id} not resolved." }
        false
      else
        context = if @object_class.unique_has_global_context?
          UniqueID.global_registry()
        else
          raise "Class #{@object_class} has non-global context, but context is nil." if !@context 
          @context
        end
         
        if @attributeReference
          if @object_class.id_mapped?(@id, context)
            unique_object = @object_class.object_for_unique_id(@id, context)
            
            @attributeReference.set(unique_object, @host)
              
            Unique.log { "  Ok." }
            true
          else
            raise "Unique objects should always be 'bound' at this point, because their registries should be loaded (object class '#{@object_class}', context host '#{@context_host}', context '#{context.class}'.)"
          end
        else
          Unique.err { "  No attributeReference for unique reference with id '#{@id}' (configPostLoadTransform not called.)" }
          false
        end
      end
    end
    
    def inspect
      "Unresolved unique object: id #{@id}, context #{@context_host}"
    end
    
    def to_s
      inspect()
    end
  end
  
  class UnresolvedGlobalID < UniqueIDConfig::UnresolvedGlobalID
  end
  
  def evaluate_id
    return nil if @unique_id.eql?(UniqueID::UNBOUND_UNIQUE_ID)

    if !self.class.unique_id_symbol
      Unique.raise "#{self.class}: No unique id symbol defined. Please call either 'use_id' or 'auto_id' during class definiton."
    end
    
    id = send(self.class.unique_id_symbol)
    if id == nil
      Unique.raise "#{self.class}: ID method '#{self.class.unique_id_symbol}' returned nil."
    end
    
    id
  end
end

class ContentWriterHash < Hash
  yaml_as "tag:david,2009:content_writer_hash"

  def self.yaml_new(klass, tag, val)
    result = ContentWriterHash.new
    val.each do |k, v|
      result[k] = v
    end
    result
  end
  
  def to_yaml(opts={})
    # workaround -- when serialising long arrays yaml can insert random object references.
    # fixed in 1.9 and later versions of 1.8?
    if PlatformRuby.v18?
      ary = [nil, nil]
    
      def ary.object_id
        nil
      end
    
      YAML::quick_emit( object_id(), opts ) do |out|
        out.seq( taguri, to_yaml_style() ) do |seq|
          each() do |k,v|
            ary[0] = k
            ary[1] = UniqueIDConfig::ContentWriter.new(v)
            seq.add(ary)
          end
        end
      end
    else
      YAML::quick_emit( object_id(), opts ) do |out|
        out.seq( taguri, to_yaml_style() ) do |seq|
          each() do |k,v|
            seq.add([k, UniqueIDConfig::ContentWriter.new(v)])
          end
        end
      end
    end
  end
  
  def inspect
    "ContentWriterHash: #{super}"
  end
end

# Include this module to designate a class as the host of Unique objects.
# Then, call the unique_id_registry method to define a registry for the objects.
# Multiple kinds of Unique objects can be hosted in a single class by defining multiple
# registries in the same class.
#
# Method usage:
# unique_id_registry kind_of_object_hosted, registry_symbol_name
module UniqueHost
  include IncludableClassMethods
  # tbd: remove requirement of uniqueidconfig. it's required so its children can reference
  # it and have the references restored on load.
  include UniqueIDConfig

  class UniqueRegistry
    include ConfigYAML
    include Viewable
    
    persistent_accessor :host
    persistent_reader :object_kind
    persistent :hash

    def initialize(host, object_kind)
      @host = host
      @object_kind = YAMLClassReference.new(object_kind)
      @hash = ContentWriterHash.new(object_id())
    end

    def object_kind_class
      @object_kind.class_ref
    end

    def [](id_or_object)
      id = id_from(id_or_object) 
      @hash.fetch(id) { raise "No such id '#{id}' (is given id of type '#{id.class}' the same type as the stored ids?)" }
    end
    
    def add(id_or_object, allow_type_conversion = true)
      id = id_from(id_or_object) 
      raise "Id '#{id}' is in use." if @hash.has_key?(id)
      if id_or_object.kind_of?(@object_kind.class_ref)
        id_or_object.bind
      elsif allow_type_conversion
        # tbd: disallow constructing objects automatically by id if desired
        @hash[id] = @object_kind.class_ref.new(id, @host)
      else
        raise "Attempt to add incorrect object of type '#{id_or_object.class}' to registry."
      end
    end
    
    def add_or_retrieve(id_or_object)
      id = id_from(id_or_object) 
      raise "Invalid nil id" if id.nil?
      @hash.fetch(id) { @object_kind.class_ref.new(id, @host) }
    end

    def empty?
      @hash.empty?
    end

    def find(&block)
      @hash.values.find(&block)
    end
        
    def has?(id_or_object)
      id = id_from(id_or_object) 
      @hash.has_key?(id)
    end
    
    def configPostLoadTransform(source, attributeReference, host)
      xform = super
      
      xform.instance_variable_get(:@hash).each_value do |value|
        value.instance_variable_set(:@unique_id, value.evaluate_id()) if !value.uniqueidconfig_can_bind_on_load?(false)
      end
      
      xform
    end
    
    def ids
      @hash.keys
    end

    def length
      @hash.length
    end
    
    def to_a
      @hash.values
    end
    
    def to_yaml(opts={})
      @hash.each_value do |v|
        # There is no requirement for Unique objects to register themselves on initialisation. If they aren't
        # registered before serialisation of their registry then they won't be restored.
        v.ensure_bind
      end
      
      super
    end
    
    def _hash
      @hash
    end
    
  protected
    def id_from(id_or_object)
      if id_or_object.kind_of?(@object_kind.class_ref)
        id_or_object.unique_id
      else
        id_or_object
      end
    end
  end
  
  module ClassMethods
    def unique_id_registry(object_kind, registry_accessor_symbol)
      symbol = registry_accessor_symbol
      
      object_kind = if object_kind
        object_kind
      else
        symbol_or_object_kind
      end
      
      persistent(symbol)

      # tbd: this won't work if Viewable is included after UniqueRegistry, but it otherwise
      # won't work unless the registry host is forced to be Viewable.
      default_view symbol, "ViewUniqueRegistry" if respond_to?(:default_view)
      
      module_eval("def #{symbol}; @#{symbol} ||= UniqueRegistry.new(self, #{object_kind}); end")
    end
  end
end

YAML::add_domain_type( "david,2009", "unique" ) do |type, val|
  objClass = Object.const_get(val['class'])
  id = val['unique_id']
  host = val['unique_context_host']
    
  if objClass.unique_has_global_context?
    Unique::Unresolved.new(id, objClass)
  else
    Unique::Unresolved.new(id, objClass, host)
  end
end

YAML::add_domain_type( "david,2009", "unique_registry" ) do |type, val|
  result = UniqueHost::UniqueRegistryOld.new
  val.each do |e|
    result[e[0]] = e[1]
  end
  
  result
end
